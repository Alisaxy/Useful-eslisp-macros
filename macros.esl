; classic Lisp let, usage: (let v-name val v-name-2 val-2 body)
(macro let (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var body (args.pop))
 (var symbols (args.filter (lambda (_ idx) (return (=== (% idx 2) 0)))))
 (var bindings (args.filter (lambda (_ idx) (return (!== (% idx 2) 0)))))
 (return `((lambda (,@symbols) (,@body)) ,@bindings))))

; variadic lambda, usage: (vlambda v-name v-name2 v-name3 rest body)
; slices the rest arguments into the rest array
(macro vlambda (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var body (args.pop))
 (var variadic (=== (. (get args (- args.length 1)) atom) "rest"))
 (if variadic (args.pop))
 (var args-len args.length)
 (if variadic 
  (return `(lambda (,@args)
    (block
     (var rest (Array.prototype.slice.call arguments ,args-len))
     (,@body))))
  (return `(lambda (,@args)
    (,@body))))))

; ternary if as a first-class expression
(macro ? (lambda (predicate left right)
 (return `(?:
  ,predicate
  ((lambda () (,@left)))
  ((lambda () (,@right)))))))

; a guard against undefined errors (depends if a good idea or not)
; ideally should use a frozen object or a fresh object as default, otherwise undefined behaviour is entirely possible
; usage example:
; (function create-identity () (block
;  (var identity (lambda ()))
;  (Object.freeze identity)
;  (return identity)))
; (var identity (create-identity))
; (= (guard identity test a b c d e f) 777)
; guards against undefined for the test.a.b.c.d.e.f path
; Warning: it does not create a new path, for that use the build macro instead!
(macro guard (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var deflt (get args 0))
 (var current (get args 1))
 (for (var i 2) (< i args.length) (++ i)
  (= current
   (array (object atom ".")
   (array (object atom "||") current deflt)
   (get args i))))
 (return current)))

; object path builder
; usage (should receive a defined unfrozen object):
; (var item (object))
; (build (object) item a b c d r 777)
; (build (object) item a b c d e f g h 777)
; (build (object) item a b d f k f g h 777)
; (macro build (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var factory (get args 0))
 (var item (get args 1))
 (var current)
 (var result item)
 (var buffer (this.gensym))
 (var assignment (args.pop))
 (var destination (args.pop))
 (for (var i 2) (< i args.length) (++ i)
  (block
   (= current (get args i))
   (= result
    (array
     (object atom "=")
     buffer
     (array
      (object atom ".")
       result
       current)
      (array
       (object atom "||")
       (array (object atom ".")
        buffer
        current)
       factory)))))
 (return `((lambda () (block
  (var ,buffer ,item)
  (= (. ,result ,destination) ,assignment)))))))
