; classic Lisp let, usage: (let v-name val v-name-2 val-2 body)
(macro let (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var body (args.pop))
 (var symbols (args.filter (lambda (_ idx) (return (=== (% idx 2) 0)))))
 (var bindings (args.filter (lambda (_ idx) (return (!== (% idx 2) 0)))))
 (return `((lambda (,@symbols) (,@body)) ,@bindings))))

; variadic lambda, usage: (vlambda v-name v-name2 v-name3 rest body)
; slices the rest arguments into the rest array
(macro vlambda (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var body (args.pop))
 (var variadic (=== (. (get args (- args.length 1)) atom) "rest"))
 (if variadic (args.pop))
 (var args-len args.length)
 (if variadic 
  (return `(lambda (,@args)
    (block
     (var rest (Array.prototype.slice.call arguments ,args-len))
     (,@body))))
  (return `(lambda (,@args)
    (,@body))))))

; ternary if as a first-class expression
(macro ? (lambda (predicate left right)
 (return `(?:
  ,predicate
  ((lambda () (,@left)))
  ((lambda () (,@right)))))))

; a guard against undefined errors (depends if a good idea or not)
; ideally should use a frozen object or a fresh object as default, otherwise undefined behaviour is entirely possible
; usage example:
; (function create-identity () (block
;  (var identity (lambda ()))
;  (Object.freeze identity)
;  (return identity)))
; (var identity (create-identity))
; (= (guard identity test a b c d e f) 777)
; guards against undefined for the test.a.b.c.d.e.f path
; Warning: it does not create a new path, for that use the build macro instead!
(macro guard (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var deflt (args.shift))
 (var current (args.shift))
 (for (var i 0) (< i args.length) (++ i)
  (= current
   (array (object atom ".")
   (array (object atom "||") current deflt)
   (get args i))))
 (return current)))

; guards for object members
; usage (var x (dotguard a b c d e f))
(macro dotguard (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var chain (array (object atom ".")))
 (var result (array (object atom "&&")))
 (for (var i 0) (< i args.length) (++ i)
  (block
   (= current (get args i))
   (chain.push current)
   (result.push (chain.slice))))
 (return result)))

; object path builder
; usage (should receive a defined unfrozen object):
; (var item (object))
; (build (object) item a b c d r 777)
; (build (object) item a b c d e f g h 777)
; (build (object) item a b d f k f g h 777)
(macro build (lambda ()
 (var args (Array.prototype.slice.call arguments 0))
 (var factory (args.shift))
 (var assignment (args.pop))
 (var chain (array (object atom ".")))
 (var result (array (object atom "&&")))
 (for (var i 0) (< i args.length) (++ i)
  (block
   (= current (get args i))
   (chain.push current)
   (result.push
    (array (object atom "=")
    (chain.slice)
    (array (object atom "||")
     (chain.slice) (?: (=== i (- args.length 1)) assignment factory))))))
 (return result)))
